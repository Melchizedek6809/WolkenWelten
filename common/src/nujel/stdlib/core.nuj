(define cadr (λ (p) "Returns the car of the cdr of pair p"
	(car (cdr p))))

(define caddr (λ (p) "Returns the car of the cdr of the cdr of pair p"
	(car (cdr (cdr p)))))

(define number? (λ (a) "Returns #t if a is a number"
	(or (int? a) (float? a) (vec? a))))

(define empty? (λ (a) "Returns #t if a is empty"
	(nil? a)))

(define pos? (λ (a) "Returns #t if a is positive"
	(>= a 0)))

(define neg? (λ (a) "Returns #t if a is negative"
	(< a 0)))

(define make-list (λ (i e l) "Returns a list of i elements containing e in every car"
	(if (<= i 0) l (make-list (-- i) e (cons e l)))))

(define sum (λ (o l s) "Returns the sum of list l with operation o and start value s"
	(if (nil? l) s (sum o (cdr l) (o s (car l))))))

(define list-ref (λ (l i) "Returns the the element of list l at location i"
	(cond ((nil? l) #nil)
	      ((<= i 0) (car l))
              (#t (list-ref (cdr l) (-- i))))))

(define ++ (λ (i) "Returns its argument + 1"
	(+ i 1)))

(define -- (λ (i) "Returns its argument - 1"
	(- i 1)))

(define reverse (λ (l r) "Returns the list l in reverse order"
	(if (nil? l) r (reverse (cdr l) (cons (car l) r)))))

(define list-length (λ (a t) "Returns the length of list a"
	(if (nil? a) t (list-length (cdr a) (++ t)))))

(define length (λ (a) "Returns the length of a"
	(cond ((string? a) (str-len a))
              ((pair? a) (list-length a))
              (#t 0))))

(define filter-iter (λ (p l r) "Iterator for filter"
	(cond ((nil? l) r)
		((p (car l)) (filter-iter p (cdr l) (cons (car l) r)))
		(#t (filter-iter p (cdr l) r)))))
(define filter (λ (p l) "Runs predicate p over every item in list l and returns a list consiting solely of items where p is true"
	(reverse (filter-iter p l #nil))))

(define map-iter (λ (f l r) "Iterator for map"
	(if (nil? l) r (map-iter f (cdr l) (cons (f (car l)) r)))))
(define map (λ (f l) "Runs f over every item in list l and returns the resulting list"
	(reverse (map-iter f l #nil))))

(define append-iter (λ (a b) "Iterator for append"
	(if (nil? a) b (append-iter (cdr a) (cons (car a) b)))))
(define append (λ (a b) "Appends to two lists a and b together"
	(append-iter (reverse a) b)))

(define sublist (λ (l start end ret) "Returns a new list containing all elements of l from start to end"
	(cond ((nil?    l) (reverse ret))
              ((neg?  end) (sublist      l      start  (+ (length l) end)))
              ((zero? end) (reverse ret))
              ((> start 0) (sublist (cdr l) (-- start) (-- end) #nil))
              ((> end   0) (sublist (cdr l) 0          (-- end) (cons (car l) ret))))))

(define list-head (λ (l k) "Returns the first k elemnts of list l"
	(sublist l 0 k)))

(define list-tail (λ (l k) "Returns the sublist of l obtained by omitting the first l elements"
	(sublist l k (length l))))

(define delete (λ (e l) "Returns a filtered list l with all elements equal to e omitted"
	(filter (λ (a) (not (eq? a e))) l)))

(define describe (λ (a) "Returns the DocString to its argument, if available"
	(if (string? (car (cl-text a))) (car (cl-text a)) "No DocString found")))

(define symbol-table (λ (i r) "Returns all a list of all symbols defined accessible from the current closure"
	(if (nil? (cl i)) r (symbol-table (++ i) (map (λ (a) (car a)) (cl i))))))

(define help (λ () "Returns a list describing every function accesible"
	(map (λ (a) (cat a "\n  " (describe a) "\n")) (symbol-table))))

(define newline (λ () "Prints a single line feed character"
	(print (br))))

(define display (λ (a) "Displays its argument"
	(print a) #nil))
